
i18n & l10n

# 货币


# 1. 背景及目标
新开三国及澳洲Re-Launch过程中，[货币i18n异常](http://wiki.intra.xiaojukeji.com/pages/editpage.action?pageId=218131567)频繁出现，严重影响用户体验及滴滴品牌形象；另一方面，国际化出行的规模及复杂度，再加上新人的持续进入，口口相传及口头约定已经无法保证全系统的高质量运作。
因此制定此货币处理标准，保证全系统在货币的录入、计算、存储、展现和传递等处理上，有统一的标准可遵循；并通过宣导、重构等手段实施该标准，最终低成本地彻底避免货币i18n异常的新发生。
# 2. 术语定义
货币i18n异常：因对多国货币的处理不够优雅，而导致的展现、金额与单位失配、限额block等通用货币异常；业务逻辑或预算配置错误导致的货币异常（如数值错误），不再此列
货币币种：使用的货币类型，如“CNY”（人民币）、“USD”（美元）
货币金额：在某币种下，表示货币数量用到的货币数字，如“CNY 100”中的“100”
货币**最小单位**：相应币种下货币的最小单位（例如：CNY的分，JPA的日元）
货币**基准单位**：相应币种下货币的基准标识单位或者最常用单位（例如：CNY的元，JPA的日元），该单位下货币金额保留两位有效小数（如果有小数）
货币**滴分单位**：相应币种的1**基准单位=1滴分*100**，**业务系统货币的最小单位目前都是滴分**（例如：1CNY的元=1CNY滴分*100，1JPA的日元=1JPA滴分*100），该单位下货币金额为整数
货币三要素：指货币金额、货币单位和货币币种
货币数据：泛指与货币相关的信息合集，一般包括货币三要素
终端：泛指native、fe等所有展现末端
精度：在基准单位下，货币金额保留的小数位数，按照约定**lu**
取整：适配当地支付习惯，对哥伦比亚、智利等国家处理货币金额，使得金额换算到基准单位后没有小数；或为了视觉及结算效果，对券、奖励、预估价等业务做去除小数处理
抹零：适配当地支付习惯，对哥伦比亚等国家处理货币金额，使得金额换算到基准单位后没有零头金额，比如抹掉“100基准单位”内的零头，目前等产品方案中
国家格式化：是“金额国家格式化”的缩写，为适配当地支付习惯，对整个国家的所有业务金额都实施精度、取整、抹零等通用格式化处理
业务格式化：是“金额业务格式化”的缩写，只在部分业务逻辑上实施精度、取整、抹零等格式化处理，或精度、取整、抹零的方式及参数随业务逻辑有不同
# 3. 标准的大原则

1. **货币单位**
1.1 因历史包袱且“滴分”无法满足诉求的国家只有科威特等少数国家，并且最坏结果只是损失一位精度（影响小），因此将原国际标准里“最小单位”承载的功能转由“滴分”承担
1.2 货币在服务端的存储、计算和传递，货币单位都使用“滴分”
1. 3 货币的展现文案，由服务端负责格式化成字符串，终端直接使用服务端传来的字符串展现，货币单位使用“基准单位”，格式化使用elvish
1.4 货币从终端录入时，货币单位是“基准单位”；从配置录入时，为保持一致，货币单位也使用“基准单位”
2. **货币金额**
2.1 推荐使用64位有符号整数来表达，避免因位数不够而导致表达大金额时溢出
2.2 录入和展现时按用户locale（语言、归属国家等）来处理数字，这种数字的纯格式化直接使用elvish
2.3 货币金额是对币种的量化，“精度”、“取整”、“抹零”所有数值计算都使用对应币种上的习惯，与用户locale（语言、归属国家等）无关，同样直接使用elvish
2.4 货币金额在展现和存储时在价值上要等价，数据及派生数据的源头先做完精度、取整、抹零等格式化处理后，再存储、展现或传递到下游
3. **货币币种**
3.1 结算都使用交易所在地的当地币种，与用户locale（语言、归属国家等）无关
3.2 不考虑支持一个国家同时流通多种货币
4. **其他**
4.1 货币数据在变量或数据库字段命名时，必须采用分段命名方式提高可读性，命名不符要求时CR打回。核心含义（该名字的用途等）、数值类型（string、int64等）、货币单位（difen、baseunit），如“display_amount_string_baseunit”，"total_fee_int64_difen"
# 4. 标准范围
包含：货币数据全生命周期的处理标准，包括录入、存储、计算、传递和展现五个阶段，并对限额等特定场景有单独的规范
不包含：本标准只解决i18n异常，其他异常如货币计算逻辑错误、预算配置错误不在考虑范畴内
# 5. 标准内容
## 5.1 存储标准
| **标准名称** | **货币存储标准** |
| --- | --- |
| **标准定义** | 描述货币数据在存储介质中的存放格式。存储介质包括rds、nosql、存储文件等 |
| **标准内容** | 货币金额：**使用64位有符号整数存储**货币金额。理由：哥伦比亚等国家汇率低导致货币金额很大，采用64位整数避免溢出
货币单位：**使用“滴分”**
货币币种：财务或账户类系统必须**存储货币币种，**统一使用[国际标准货币](https://www.iso.org/iso-4217-currency-codes.html)**的**三个字符编码，比如人民币是 CNY，字母全部**大写。**理由**：**财务和账户类系统会处理多笔订单，为保证漫游、当地币种切换等场景下仍能正常结算，必须为每笔交易及余额等存储币种类型。 |
| **标准级别** | **强制** |
| **实现建议** | 货币金额：BIGINT(20)，**禁止使用浮点型和32位类型存储货币金额**
货币单位：VARCHAR(4)，可直接约定为“滴分”，不额外使用单独的字段
货币币种：VARCHAR(4) |

## 
5.2 计算标准
| **标准名称** | **货币计算标准** |
| --- | --- |
| **标准定义** | 描述程序内计算货币金额时的标准，包括货币金额在内存中的变量/常量表示。 |
| **标准内容** | 货币金额的表示：使用**64位有符号整数，避免浮点计算**。**禁止使用32位整数**存储货币，防止溢出风险！
货币单位：使用“滴分”，不额外使用单独的字段
数值格式化：货币数据的生产源头做取整、抹零、精度等格式化处理；服务使用外部数据派生（如分账）出新的货币数据时，应对该派生数据应做格式化处理
   - 分账数据格式化：建议先对总账做格式化，之后每分账派生出一份数据就立即做格式化处理，除第一份分账数据外，其他分账都用减法得出，确保账平且无负数
 |
| **标准级别** | **强制** |
| **实现建议** | 货币金额的表示：
   - PHP：推荐INTEGER
   - GOLANG：推荐INT64
   - JAVA：推荐LONG
   - C++：推荐int64_t

因为历史包袱等原因，部分程序还是使用了浮点预算，elvish将提供通用基础库帮助程序将浮点预算转成整数运算
数值格式化在业务间实现差异较大，先由业务自行实现，后面elvish提供单独的helper函数来辅助处理 |

## 5.3 传递标准
| **标准名称** | **货币传递标准** |
| --- | --- |
| **标准定义** | 描述货币数据在服务间或接口间传递时的格式。传递方式包括thrift rpc、http、sdk调用等 |
| **标准内容** | 货币金额：采用**64位有符号整数**
货币单位：使用**“滴分”**
货币币种：财务或账户类系统内部必须传递**货币币种，**统一使用[国际标准货币](https://www.iso.org/iso-4217-currency-codes.html)**的**三个字符编码，比如人民币是 CNY，字母全部**大写** |
| **标准级别** | **强制** |
| **实现建议** | 货币金额：实现推荐**64位有符号整型**声明
货币单位：接口中不做声明，约定为滴分单位
货币币种：统一使用[国际标准货币](https://www.iso.org/iso-4217-currency-codes.html)**的**三个字符编码，比如人民币是 CNY，字母全部**大写** |

## 5.4 展现标准
| **标准名称** | **货币展现标准** |
| --- | --- |
| **标准定义** | 描述货币在终端展现时的规范，终端包括司机端、乘客端、内部平台、H5页面等 |
| **标准内容** | 文案的生成：由服务端负责格式化成字符串，终端直接使用服务端传来的字符串展现，货币单位使用“基准单位”，货币金额保留两位有效小数（如果有小数）；格式化使用elvish sdk
**展现和存储要保持一致。**理由：不一致会导致用户看到的钱和实际处理的钱不一致，有体验和法务风险。
   - **格式化sdk不做数值处理**：文案中的金额，与存储或内存中的金额应该等值，所以格式化sdk原则上不会做任何数值处理（如中国传入“10.01”就展示“10.01”）
   - **国家格式化展现和存储都要实现**：每个国家对货币的小数位数（精度）、是否有小数（取整）、是否抹去小面值零头（抹零）都有本地化格式要求，格式化sdk的通用展现接口会支持这种国家级格式化金额处理。（如哥伦比亚传入“10,00”，会取整成"10"）。 备注：正常情况下，调用者会根据国家级格式化要求，将存储或内存中字段做取整、抹零或精度处理；格式化sdk按国家级格式化要求去掉没有意义的小数，是能保证展现和存储一致的。异常情况下，调用者未按要求做格式化处理，此时无论格式化sdk是否做格式化，都难以保证展现和存储的一致性，因此展现sdk选择继续做格式化，但当格式化时发现有数值精度损失报警出来即可。
   - **业务格式化**：券、奖励等局部业务为了让数字更醒目，期望货币金额从生成到展现都没有小数，此时业务可调用格式化sdk中的特殊展现接口来满足需求
 |
| **标准级别** | **强制** |
| **实现建议** | elvish sdk接口：**elvish **[currency api](http://10.179.88.174:8901/manual/api/currency/formatByCountry.html)
格式化样式：分ISO（国际标准）和本地化（LOCALE）两种，如示例5.4.1；默认使用本地化，用户无需关心本地化定制样式细节（如[【IBT货币本地化数据集】](https://git.xiaojukeji.com/Elvish/Elvish-lib-php/blob/feature_qa/tests/cases/currencyCase.txt)）
特殊展现：部分场景下，需要对货币数据中的金额放大或高亮显示，服务端能通过格式化sdk生成结构化展示片段集合，终端从集合中提取到货币金额片段后直接做特殊展示处理即可
高亮声明样式：是特殊展现的特例，通过标志“{}”让终端能获取到结构化的“货币金额”字段，如示例5.4.2 |

**
示例5.4.1：格式化样式**

| **样式名** | **标准描述** | **举例** |
| --- | --- | --- |
| ISO 样式 | ICU 标准化货币展示 | 1234567.89=>JPY 1,234,568 |
| LOCALE 样式 | 本地化定制样式展示 | 1234567.89=>1,234,568円 |

**示例5.4.2：高亮示例**

| **样式名** | **高亮标识** | **举例** |
| --- | --- | --- |
| 数字高亮样式 | {} | ISO:    1234567.89=>{1,234,568}円LOCALE: 1234567.89=>JPY {1,234,568} |

## 5.5 录入标准
| **标准名称** | **货币录入标准** |
| --- | --- |
| **标准定义** | 描述用户通过终端页面录入货币数据时的规范。终端包括司机端、乘客端、内部平台、H5页面等 |
| **标准内容** | **货币数据录入页面：**
   - 货币单位采用“基准单位”
   - 货币金额采用本地化样式，保留两位有效小数（如果有小数）
   - 货币币种采用[国际标准货币](https://www.iso.org/iso-4217-currency-codes.html)**的**三个字符编码，比如人民币是 CNY，字母全部**大写**
 |
| **标准级别** | **建议** |
| **实现建议** | 横向技术与端上共建基于elvish的[多语言货币录入组件](http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=219317300) |



| **标准名称** | **货币录入的传输标准** |
| --- | --- |
| **标准定义** | 描述货币录入后，货币数据传输到服务端使用时的规范。 |
| **标准内容** | 货币金额的格式化：终端将用户录入的本地化金额转成普通数字，存储到配置文件后向服务端传输
货币数据的传输：
   - 货币金额：终端格式化后的普通数字串
   - 货币币种：采用[国际标准货币](https://www.iso.org/iso-4217-currency-codes.html)**的**三个字符编码，比如人民币是 CNY，字母全部**大写**。也可只传输“国家”给服务端，由服务端通过elvish获取到币种
   - 货币单位：约定为“基准单位”，不额外使用单独的字段来传输

货币数据在服务端的解析：服务端读取传输数据后，按“滴分”做转换后，再交给服务内部使用 |
| **标准级别** | **建议** |
| **实现建议** | 货币金额的格式化：非本地化输入时，直接使用用户输入的数字；支持本地化输入后，推荐使用elvish中的[多语言货币录入组件](http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=219317300)处理
货币金额的传输：参考示例5.5.1
货币数据的解析：如示例5.5.2，调用elvish parse接口即可 |

**
示例5.5.1：传输内容示例**

| **货币金额** | **货币币种（有困难则使用国家代替）** | **货币单位（约定为“基准单位”，可省）** |
| --- | --- | --- |
| 123456789 | COL | —— |
| 1000.11 | CNY | —— |

**示例5.5.2：解析示例**

| **输入货币数据** | **输入货币币种（有困难则使用国家代替）** | **输入货币单位（约定为“基准单位”，可省）** | **返回解析（最小单位）** | **返回解析（滴分单位）** |
| --- | --- | --- | --- | --- |
| **输入货币数据** | **输入货币币种（有困难则使用国家代替）** | **输入货币单位（约定为“基准单位”，可省）** | **返回解析（最小单位）** | **返回解析（滴分单位）** |
| 123456789 | COL | —— | 12345678900 | 12345678900 |
| 1000.11 | CNY | —— | 100011 | 100011 |

## 5.6 限额标准
限额作为货币数据的一种，同样遵守前述标准，但有如下的额外特点：
**兜底限额**：用来预防极端情况导致的字段溢出或大额资损而设置的额度，需要适配各国（按汇率适配）并可配置化，推荐采用elvish sdk的限额接口
**预算限额**：业务层为控制预算而设置的预算额度，需要按国能配置，最好做到能在控制台页面上配置
**限额预警**：限额达到上限的某个水位（如80%），意味着发生了不符预期的资金流转，可能引发严重的资损和用户体验问题，**需要一级报警**出来。如果使用elvish sdk的兜底限额，限额预警由elvish统一配置即可
## 5.7 日志打印标准
大部分时候用来追查问题，随打印上下文而格式各异，而打印上下文已经涵盖在前述环节中，此处不再赘述。
# 6. 标准落地
见 [货币处理最佳实践](http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=222683972)


### 一、货币处理10条军规
术语参见  [货币处理标准——术语定义](https://dwz.cn/QMm12HHh)

1. 只允许服务端生成货币文案
解释：货币文案必须由服务端生成，禁止客户端和前端生成文案。服务端生成文案更收敛（服务端一份数据会在多个终端展现）和更可控（如能快速升级止损）

2. 必须使用elvish生成货币文案
解释：服务端必须使用elvish来生成最终的货币文案字符串。货币文案的格式化是通用的，统一调用elvish来实现

3. 货币金额的展现由locale语言决定，货币符号及货币结算由币种决定
解释：金额数字展现适配locale语言（如en-US），更能让用户看懂；货币交易是按当地币种进行的，因此货币符号及其结算也应由当地币种决定，如“en-US”美国人在墨西哥打车，数字展现成美式英语风格，但货币符号展现使用墨西哥货币符号“MX$”

4. 计算、存储和传递过程中必须使用64位符号整数，必须使用滴分单位
解释：货币数据在计算、存储和传递过程中，使用64位有符号整数保证金额不溢出，使用滴分单位保证上下游一致；录入和展现时，使用用户更习惯的基准单位，金额保留两位有效小数（如果有小数）

5. 取整抹零处理由数据生产源头负责
解释：货币金额在展现和存储上要一致（价值上等价），数据及派生数据的源头做统一的精度、取整、抹零处理后，再存储、展现或传递到下游，以保证数据的全局一致性，如“取消费”由服务管控产生，必须由服务管控做取整抹零处理，其他使用方直接使用即可

6. 使用外部货币数据时，必须确认货币三要素
解释：使用配置文件或外部服务的货币数据时，必须确认货币金额、货币单位和货币币种三要素

7. 禁止原地修改货币数据的字段类型，不允许修改货币单位
解释：货币数据的字段类型不允许原地修改，只能通过新增字段来做兼容升级，这与一般的通信协议如thrift保持一致；不允许修改货币单位，如将滴分升级成基准单位

8. 必须在2个以上国家做diff测试，RD必须检查展现效果
解释：货币升级必须在2个以上国家做接口diff和页面展现diff测试，上线时RD必须检查货币展现页面的效果

9. 使用分段命名
解释：货币数据在变量或数据库字段命名时，必须采用分段命名方式提高可读性，命名不符要求时CR打回。包含核心含义（该名字的用途等）、数值类型（string、int64等）、货币单位（difen、baseunit）等，如“display_amount_string_baseunit”，"total_fee_int64_difen"

10. 禁止将限额在代码中写死，限额值要按汇率去调配
解释：限额要做成可配置的，具体限额值应将人民币金额按汇率折算成当地货币金额，防止不合理的限额block住新开功能或新开国家
### 二、货币处理标准要点（前为口诀，后为解释）
货币处理标准是对军规的补充详细标准见 [货币处理标准](http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=218125167)

1. 货币处理五阶段，录入、计算、存储、传递和展现；货币数据三要素，金额、单位和币种；变量命名分多段，含义、类型和单位
a. 货币处理分录入、计算、存储、传递和展现5个阶段
b. 货币数据有货币金额、货币单位和货币币种三个要素
c. 货币数据在变量或数据库字段命名时，必须采用分段命名方式提高可读性，命名不符要求时CR打回。核心含义（该名字的用途等）、数值类型（string、int64等）、货币单位（difen、baseunit），如“display_amount_string_baseunit”，"total_fee_int64_difen"

2. 计算、存储和传递，64位整数不溢出，滴分上下保一致；录入和展现，基准单位保体验
a. 货币数据在计算、存储和传递过程中，使用64位有符号整数保证金额不溢出，使用滴分单位保证上下游一致
b. 货币数据录入和展现过程中，使用基准单位，保留两位有效小数（如果有小数）

3. 展现文案全放服务端，格式化elvish来帮忙；高亮展现不用怕，elvish也支持；数字风格随语言，符号数值随币种
a. 货币的展现文案，由服务端负责格式化成字符串，终端直接使用服务端传来的字符串展现，货币单位使用“基准单位”，格式化使用elvish
b. 货币数字的展现风格由locale语言决定，货币符号及货币数值处理由当地币种决定
c. elvish支持高亮展现

4. 存储传递要一致，先在数据源头取整又抹零，再做存储、展现和传递，未来elvish会帮忙
a. 货币金额在展现和存储时在价值上要等价，数据及派生数据的源头先做完精度、取整、抹零等格式化处理后，再存储、展现或传递到下游
b. elvish未来会提供helper函数来辅助处理

5. 限额要做配置化，大小根据汇率来调配
a. 限额要做成可配置的，具体限额值应将可接受的人民币金额按汇率折算成当地货币金额
b. 限额可用来防止极端输入下的大额资损及计算溢出
### 三、elvish货币sdk简介
format接口：根据locale和币种/国家，将输入的货币金额格式化成完整的货币文案
splitFormat接口：根据locale和币种/国家，将输入的货币金额按标准格式化后，将完整信息切分输出到三个字符串，第一个串是合标的货币符号（如完整展现有空格，会包含在此串中），第二个串是合标的货币金额，第三个串是符号和金额的展现顺序，适用于货币金额的简单的特殊展现，终端使用这三个字符串能完整拼出合标的货币展现文案
displayFormat接口：根据locale和币种/国家，将货币金额、前缀文案、后缀文案按标准完整格式化成串后，将串按展现顺序切成多个片段，方便终端边遍历边对每个片段做特殊展现，适合货币夹在普通文案中间的场景，如“已经为您优惠$ 10.01元”这类复杂文案。 该接口会结合文案专项治理来实现

详细文档见：
[elvish-lib-php文档](https://git.xiaojukeji.com/Elvish/Elvish-lib-php/tree/feature_qa)
[elvish-lib-golang文档](https://git.xiaojukeji.com/Elvish/elvish-lib-golang/tree/feature_qa)
[elvish-lib-java文档](https://git.xiaojukeji.com/Elvish/elvish-lib-java/tree/feature_qa)
c++版暂没有用户，先不维护
### 四、老服务合标改造指南
更多过程请参考：[00 货币改造迁移方案](http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=218954650)
**立即执行：**新接口合标
**一期改造（6.26~08.09）：**展现合标，少量服务的限额及字段类型扩容（属于计算和存储合标）
**二期改造（待定）：**计算和存储合标（包括精度、取整、抹零处理）、传递合标、录入合标

A. 新接口合标：合标成本最低，立即执行
B. 展现合标：最容易拿到收益，分“文案格式化使用elvish” 和 “端文案下沉”两步
**a. 文案格式化使用elvish**：对output出去的文案字段使用elvish来生成

   - 对“符号+金额”完整文案整体使用一个字符串的，使用elvish format来生成
   - 对“符号”或“金额”有单独字符串的，使用elvish splitFormat分别生成符号和金额

**b. 端文案下沉：**分4步走

   1. 根据终端梳理的接口，梳理出每个接口调用链上的货币服务
   2. 并结合每个服务自己梳理出的不符合文案下沉要求的接口做改造（包括前一阶段使用splitformat接口），改造时新加一个文案字段，内容使用elvish format接口生成后再填充
   3. 每个服务ready后，要求其直接上游切到使用文案新字段（**双读容错：**如果获取不到新字段，则继续使用老字段，避免部分机器升级新版本不成功时的badcase）
   4. 在服务端都ready后，端发版切新字段（**双读容错：**如果获取不到新字段，继续使用老字段，并且有apollo灰度）

C. 计算和存储合标：改造成本较大，但服务自身就能控制
D. 传递合标：涉及到上游配合，改造成本最大
E. 录入合标：2C用户录入少，2B国外用户使用当地风格录入的需求暂不强烈（国外用户当前使用英语录入，因en-US的货币数字风格与zh-CN一致，无需改造）

# 时间
### 一、时间处理x条军规
#### **定义：**
**北京时间：**北京时间是[中国](https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD/1122445)采用东八区的时间，滴滴大多数中台服务（订单）起始于国内，一直沿用的北京时间，美东服务器也是北京时间
**本地时间：**面向用户的时间，需要使用用户的所处时（时间）空（空间、位置）的时间
**夏令时**：一种为节约能源而人为规定地方时间的制度，在这一制度实行期间所采用的时间称为“[夏令时间](https://zh.wikipedia.org/wiki/%E5%A4%8F%E6%97%B6%E5%88%B6)”
**时间字符串：**人们常用的时间格式："2020-2-7 02:58:00","2020-2-7", "02:58:00" 
**数据库时间：**当前滴滴数据库大多数时间类型都是DATETIME,该类型样式为"YYYY-MM-DD HH:mm:ss"
**时间对象：**不同编程语言读取数据库时间后包装类型不一样，除了PHP其他语言都是对象类型，可以直接获取到时间戳（java : java.sql.Timestamp，Golang:time.Time，PHP:字符串）
**时间戳：**unix时间戳，是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，世界上任一台电脑此刻产生的时间戳都是一样的，时间戳可以精确地表示某一时刻，并且**与时区无关**
**日历：**对年月日的具体规定,参见：[格里高利历](https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%87%8C%E6%9B%86)
**时区：**本文只采用[IANA的定义](https://www.iana.org/time-zones)，示例："Asia/Shanghai","America/New_York"
**时区偏移:** 别称 utcoffset ，示例:540(分钟),与格林威治/ UTC 时间的时区偏移量
**cityid:**滴滴统一城市id，Elvish通过cityid与时区的关联，能够准确拿到指定城市的时区

更多介绍参见：[时间、历法、时区和令时-术语与背景知识](http://way.xiaojukeji.com/article/17541)
#### **军规：**
**存储类**

1. 北京时间或者时间戳可以表示过去、当前的时间
解释1：过去和现在的时间是确定的，未来的时间遇到夏令时就变得不确定
解释2：滴滴绝大数系统存储的是北京时间，可以直接转为时间戳
注意：字符串格式（"2020-03-19 12:20:30"）转为时间戳需要明确知道归属城市

2. 记录未来的时间使用本地时间字符串(格式："YYYY-MM-DD HH:mm:ss")，如果使用北京时间（或者时间戳）最长不能存储超出未来一个月的时间
解释1： 未来的时间，可能随着夏令时调整而变化，比如在2018年的时候定义一个巴西时间" 2019-10-20 03:00:00"生效一个活动，我们建议使用字符串存储时间，如果使用时间戳，巴西2019年取消了夏令时，那么时间表达就不准确了，所以定义一个未来的时间，请使用字符串时间 + cityid （如：墨西哥城当地时间 2021年11月11日 ： 52090100(墨西哥城cityid) + "2021-11-11 00:00:00"）绝对不要使用utcoffset(会变化)解释2：虽然夏令时会调整，但是通常都会提前通知，Elvish能够保证未来一个月的时间戳是准确的
注意：存储整个日期（例如生日和周年纪念日）时，使用字符串即可,如果期望使用datetime存储，建议存储当天的中午12:00(生日、纪念日通常只显示年月日，中午12点可以避免因为时区导致错一天)

3. 时区的表达必须使用cityid ,逐步废弃utcoffset
解释1：当一条记录里有多个时间记录时，一个utcoffset无法表达多个时区偏移，比如夏令时切换时，上车和下车时间对应的utcoffset不一致
解释2：elvish通过cityid能够准确的获取时区，使用cityid而不是IANA的时区，原因是滴滴的出行和外卖等业务都是LBS类业务，天然有城市信息（cityid），所以用cityid来表示“时区”成本比较低

**显示类**

1. 时间的显示与当时的时区有关，与现在时区无关 ,必须使用Elvish处理时间
解释：已发生的时间，请按照当时的时区表达，Elvish提供了标准格式的时间转换，适配不同国家，方便业务使用

2. 面向用户时间的显示格式务必遵照产品约定 [日期时间本地化显示](http://cooper.didichuxing.com/docs/sheet/36961918#WhmkK)
解释：结合国际标准和当地习惯，Elvish能够输出当地标准时间格式，请务必遵守该约定

3. 端上的个性化展示，由后端提供时间戳，前端基于时间戳和cityid通过Elvish做统一格式化展示
解释：应当避免后端提供的时间字符串被二次加工， 时间字符串样式可能会被调整，只能用于显示

**计算与传输**

1. 时长计算必须使用时间戳，日历计算必须使用Elvish
解释：时长计算与令时、时区无关，使用时间戳即可，elvish提供了天、周、月等日历相关计算方法
示例：上车时间为悉尼时间2020-04-05 **01:50(utc+11)时间戳：1586011800**，下车为悉尼时间是2020-04-05 **01:20(utc+10)时间戳：1586013600，打车时长1800秒 = 30分钟**（悉尼4月5日2点做了夏令时切换）**
**

2. 端上查询时间应该明确为北京时间或者当地时间字符串
解释：部分业务基于offset把北京时间转为当地时间，或者把当地时间转为北京时间，无形之中增加了理解成本，极易出错
建议1：增加bj_time,bj_start_time 或者locale_time,locale_start_time 兼容字段，方便上下游理解
建议2：目前绝大数系统传输都是当地时间，如果业务使用的是北京时间，建议增加locale时间

**其他类**

1.  定时任务，请避开令时调整时刻，并要注意幂等
解释：liunx cron job 虽然考虑令时调整，为了避免业务的损失，最好避开令时调整时间，为了防止任务多次执行，务必考虑幂等
解释：[夏令时调整时刻表](http://cooper.didichuxing.com/docs/sheet/53148170)
### 二、时间处理标准要点（前为口诀，后为解释）
时间处理标准是对军规的补充详细标准见 [时间处理标准](http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=285760593)

1. 时间处理五阶段，录入、计算、存储、传递和展现；时间数据三要素，locale、cityid和时间戳（北京时间）
a. 时间处理分录入、计算、存储、传递和展现5个阶段
b. 时间数据有locale、cityid和时间戳（北京时间）三个要素
c. **北京时间由于无夏令时且我们的服务器都是北京时间**，所以可以直接获取时间戳，所以北京时间等同于时间戳

2. 计算和传递，时间带上cityid，表示该时间与cityid有关,数据库存储使用北京时间（时间戳），活动时间使用字符串
   1. 时间数据在计算、传递过程中带上cityid，明确时间归属地 cityid优先级：**业务cityid》=订单的cityid   > location_cityid（标准公参）**
   2. 存储时候北京时间在可读性比较好，且能使用函数直接转为时间戳
   3. 活动时间是未来的定义，使用字符串能准确表达归属地时间。

3. 展现文案服务端和客户端因地制宜，格式化elvish来帮忙；风格随locale，时间显示随城市
a. 时间的格式和场景比较多，所以服务端和客户端按需处理，格式化使用elvish
b. 时间的展现风格由locale语言决定，显示为几点是由所在城市(时区)决定

4. 存储带上cityid,日历计算elvish能支持
a. 存储使用北京时间，写入和取出都需要cityid才能准确表达函数
b.日历计算获取周开始结束，月开始与结束，elvish也支持

### 三、elvish时间sdk简介
format接口：根据locale、城市、秒时间戳、样式，把输入的时间格式化为指定的时间字符串
getXX接口：根据locale、城市、时间字符串、样式，把指定城市的时间字符串转为 时间戳
duration接口：根据locale、秒，讲输入的时间转为 xx分xx秒 等格式
calendar 接口：根据城市和时间戳，获取指定时间的 周开始与结束 月开始与结束的时间戳

详细文档见：
[elvish-lib-php文档](http://10.179.88.174:8901/manual/api/date/)
[elvish-lib-golang文档](https://git.xiaojukeji.com/Elvish/elvish-lib-golang/blob/master/README.md)
[elvish-lib-java文档](https://git.xiaojukeji.com/Elvish/elvish-lib-java/blob/master/readme.md)
[IOS-Android-JS-Elvish接入文档](http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=264873066)

### 四、老服务合标改造指南
更多过程请参考：[I18N时间改造方案](http://wiki.intra.xiaojukeji.com/pages/viewpage.action?pageId=304548717)
**立即执行：**新服务合标 （vamos）
A. 新接口合标：合标成本最低，立即执行
B. 展现合标：最容易拿到收益，分“公参透传” 和 “服务端合规改造”，“端文案改造” 三步
**a.公参透传**

   - 端上已经将指定公参locale 和location_cityid（都在hintcontent里）透传下去 
   - 服务端也需要把公参透传下去

**a. 服务端合规**：包含展示和时间转换以及计算

   - 时间戳的转换，使用elvish的 get相关函数
   - 对于时间格式化的，使用format相关函数

**b. 端文案改造：**

   1. 同样使用elvish改造即可
   2. 不需要考虑前后端的耦合。

C. 计算和存储合标：改造成本较大，但服务自身就能控制，服务与服务之间相互隔离
D. 传递合标：接口之前相互明确即可，改造成本低，遇到时间与location_city不一致，需要做兼容改造：新增入参表达
E. 录入合标：增加一列cityid即可，确保录入的时间与该城市一致，如果不一致需要与下游说明，并逐步迁移

# 度量衡



# 数字


# 电话


# 语言-地区
**
LOCALE：**区域信息集，是本地化处理的最核心参数。
**标准的LOCALE包括三个部分：语言代码(language code)，地域代码(country code)和字符编码(character encoding)。**例如UNIX默认LOCALE为en_US.UTF-8。
实际使用中，由于滴滴的字符编码默认都是UTF-8，**LOCALE包含两部分：语言代码（language code），地域代码（country code）**，例如 "en_US"，"pt_BR"，"es_BR"等

**语言代码（language code）：**标识界面语言，用[ISO 639](http://www.loc.gov/standards/iso639-2/) 标准定义的“**小写两字节码**”。例如Spanish => "es"，English =>"en"，Franch => "fr"等
**地域代码（country code）：**标识用户地区，用[ISO 3166](https://www.iso.org/iso-3166-country-codes.html)标准定义的“**大写两字节码**”。例如Spain => "ES"，Mexico =>"MX"等。

备注：由于不同操作系统间传递连接符不一样，推荐“语言_地区”，兼容“语言-地区”

# 其他()

# 翻译


